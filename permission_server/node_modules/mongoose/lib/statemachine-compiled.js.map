{"version":3,"sources":["statemachine.js"],"names":[],"mappings":"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","file":"statemachine-compiled.js","sourcesContent":["\n/*!\n * Module dependencies.\n */\n\nvar utils = require('./utils');\n\n/*!\n * StateMachine represents a minimal `interface` for the\n * constructors it builds via StateMachine.ctor(...).\n *\n * @api private\n */\n\nvar StateMachine = module.exports = exports = function StateMachine () {\n}\n\n/*!\n * StateMachine.ctor('state1', 'state2', ...)\n * A factory method for subclassing StateMachine.\n * The arguments are a list of states. For each state,\n * the constructor's prototype gets state transition\n * methods named after each state. These transition methods\n * place their path argument into the given state.\n *\n * @param {String} state\n * @param {String} [state]\n * @return {Function} subclass constructor\n * @private\n */\n\nStateMachine.ctor = function () {\n  var states = utils.args(arguments);\n\n  var ctor = function () {\n    StateMachine.apply(this, arguments);\n    this.paths = {};\n    this.states = {};\n    this.stateNames = states;\n\n    var i = states.length\n      , state;\n\n    while (i--) {\n      state = states[i];\n      this.states[state] = {};\n    }\n  };\n\n  ctor.prototype = new StateMachine();\n\n  states.forEach(function (state) {\n    // Changes the `path`'s state to `state`.\n    ctor.prototype[state] = function (path) {\n      this._changeState(path, state);\n    }\n  });\n\n  return ctor;\n};\n\n/*!\n * This function is wrapped by the state change functions:\n *\n * - `require(path)`\n * - `modify(path)`\n * - `init(path)`\n *\n * @api private\n */\n\nStateMachine.prototype._changeState = function _changeState (path, nextState) {\n  var prevBucket = this.states[this.paths[path]];\n  if (prevBucket) delete prevBucket[path];\n\n  this.paths[path] = nextState;\n  this.states[nextState][path] = true;\n}\n\n/*!\n * ignore\n */\n\nStateMachine.prototype.clear = function clear (state) {\n  var keys = Object.keys(this.states[state])\n    , i = keys.length\n    , path\n\n  while (i--) {\n    path = keys[i];\n    delete this.states[state][path];\n    delete this.paths[path];\n  }\n}\n\n/*!\n * Checks to see if at least one path is in the states passed in via `arguments`\n * e.g., this.some('required', 'inited')\n *\n * @param {String} state that we want to check for.\n * @private\n */\n\nStateMachine.prototype.some = function some () {\n  var self = this;\n  var what = arguments.length ? arguments : this.stateNames;\n  return Array.prototype.some.call(what, function (state) {\n    return Object.keys(self.states[state]).length;\n  });\n}\n\n/*!\n * This function builds the functions that get assigned to `forEach` and `map`,\n * since both of those methods share a lot of the same logic.\n *\n * @param {String} iterMethod is either 'forEach' or 'map'\n * @return {Function}\n * @api private\n */\n\nStateMachine.prototype._iter = function _iter (iterMethod) {\n  return function () {\n    var numArgs = arguments.length\n      , states = utils.args(arguments, 0, numArgs-1)\n      , callback = arguments[numArgs-1];\n\n    if (!states.length) states = this.stateNames;\n\n    var self = this;\n\n    var paths = states.reduce(function (paths, state) {\n      return paths.concat(Object.keys(self.states[state]));\n    }, []);\n\n    return paths[iterMethod](function (path, i, paths) {\n      return callback(path, i, paths);\n    });\n  };\n}\n\n/*!\n * Iterates over the paths that belong to one of the parameter states.\n *\n * The function profile can look like:\n * this.forEach(state1, fn);         // iterates over all paths in state1\n * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\n * this.forEach(fn);                 // iterates over all paths in all states\n *\n * @param {String} [state]\n * @param {String} [state]\n * @param {Function} callback\n * @private\n */\n\nStateMachine.prototype.forEach = function forEach () {\n  this.forEach = this._iter('forEach');\n  return this.forEach.apply(this, arguments);\n}\n\n/*!\n * Maps over the paths that belong to one of the parameter states.\n *\n * The function profile can look like:\n * this.forEach(state1, fn);         // iterates over all paths in state1\n * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\n * this.forEach(fn);                 // iterates over all paths in all states\n *\n * @param {String} [state]\n * @param {String} [state]\n * @param {Function} callback\n * @return {Array}\n * @private\n */\n\nStateMachine.prototype.map = function map () {\n  this.map = this._iter('map');\n  return this.map.apply(this, arguments);\n}\n\n"]}
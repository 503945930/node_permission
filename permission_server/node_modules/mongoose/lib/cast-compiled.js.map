{"version":3,"sources":["cast.js"],"names":[],"mappings":"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","file":"cast-compiled.js","sourcesContent":["/*!\n * Module dependencies.\n */\n\nvar utils = require('./utils');\nvar Types = require('./schema/index');\n\n/**\n * Handles internal casting for queries\n *\n * @param {Schema} schema\n * @param {Object obj Object to cast\n * @api private\n */\n\nvar cast = module.exports = function(schema, obj) {\n  var paths = Object.keys(obj)\n    , i = paths.length\n    , any$conditionals\n    , schematype\n    , nested\n    , path\n    , type\n    , val;\n\n  while (i--) {\n    path = paths[i];\n    val = obj[path];\n\n    if ('$or' === path || '$nor' === path || '$and' === path) {\n      var k = val.length;\n      var orComponentQuery;\n\n      while (k--) {\n        val[k] = cast(schema, val[k]);\n      }\n\n    } else if (path === '$where') {\n      type = typeof val;\n\n      if ('string' !== type && 'function' !== type) {\n        throw new Error(\"Must have a string or function for $where\");\n      }\n\n      if ('function' === type) {\n        obj[path] = val.toString();\n      }\n\n      continue;\n\n    } else {\n\n      if (!schema) {\n        // no casting for Mixed types\n        continue;\n      }\n\n      schematype = schema.path(path);\n\n      if (!schematype) {\n        // Handle potential embedded array queries\n        var split = path.split('.')\n          , j = split.length\n          , pathFirstHalf\n          , pathLastHalf\n          , remainingConds\n          , castingQuery;\n\n        // Find the part of the var path that is a path of the Schema\n        while (j--) {\n          pathFirstHalf = split.slice(0, j).join('.');\n          schematype = schema.path(pathFirstHalf);\n          if (schematype) break;\n        }\n\n        // If a substring of the input path resolves to an actual real path...\n        if (schematype) {\n          // Apply the casting; similar code for $elemMatch in schema/array.js\n          if (schematype.caster && schematype.caster.schema) {\n            remainingConds = {};\n            pathLastHalf = split.slice(j).join('.');\n            remainingConds[pathLastHalf] = val;\n            obj[path] = cast(schematype.caster.schema, remainingConds)[pathLastHalf];\n          } else {\n            obj[path] = val;\n          }\n          continue;\n        }\n\n        if (utils.isObject(val)) {\n          // handle geo schemas that use object notation\n          // { loc: { long: Number, lat: Number }\n\n          var geo = val.$near ? '$near' :\n                    val.$nearSphere ? '$nearSphere' :\n                    val.$within ? '$within' :\n                    val.$geoIntersects ? '$geoIntersects' : '';\n\n          if (!geo) {\n            continue;\n          }\n\n          var numbertype = new Types.Number('__QueryCasting__')\n          var value = val[geo];\n\n          if (val.$maxDistance) {\n            val.$maxDistance = numbertype.castForQuery(val.$maxDistance);\n          }\n\n          if ('$within' == geo) {\n            var withinType = value.$center\n                          || value.$centerSphere\n                          || value.$box\n                          || value.$polygon;\n\n            if (!withinType) {\n              throw new Error('Bad $within paramater: ' + JSON.stringify(val));\n            }\n\n            value = withinType;\n\n          } else if ('$near' == geo &&\n              'string' == typeof value.type && Array.isArray(value.coordinates)) {\n            // geojson; cast the coordinates\n            value = value.coordinates;\n\n          } else if (('$near' == geo || '$nearSphere' == geo || '$geoIntersects' == geo) &&\n              value.$geometry && 'string' == typeof value.$geometry.type &&\n              Array.isArray(value.$geometry.coordinates)) {\n            // geojson; cast the coordinates\n            value = value.$geometry.coordinates;\n          }\n\n          ;(function _cast (val) {\n            if (Array.isArray(val)) {\n              val.forEach(function (item, i) {\n                if (Array.isArray(item) || utils.isObject(item)) {\n                  return _cast(item);\n                }\n                val[i] = numbertype.castForQuery(item);\n              });\n            } else {\n              var nearKeys= Object.keys(val);\n              var nearLen = nearKeys.length;\n              while (nearLen--) {\n                var nkey = nearKeys[nearLen];\n                var item = val[nkey];\n                if (Array.isArray(item) || utils.isObject(item)) {\n                  _cast(item);\n                  val[nkey] = item;\n                } else {\n                  val[nkey] = numbertype.castForQuery(item);\n                }\n              }\n            }\n          })(value);\n        }\n\n      } else if (val === null || val === undefined) {\n        continue;\n      } else if ('Object' === val.constructor.name) {\n\n        any$conditionals = Object.keys(val).some(function (k) {\n          return k.charAt(0) === '$' && k !== '$id' && k !== '$ref';\n        });\n\n        if (!any$conditionals) {\n          obj[path] = schematype.castForQuery(val);\n        } else {\n\n          var ks = Object.keys(val)\n            , k = ks.length\n            , $cond;\n\n          while (k--) {\n            $cond = ks[k];\n            nested = val[$cond];\n\n            if ('$exists' === $cond) {\n              if ('boolean' !== typeof nested) {\n                throw new Error(\"$exists parameter must be Boolean\");\n              }\n              continue;\n            }\n\n            if ('$type' === $cond) {\n              if ('number' !== typeof nested) {\n                throw new Error(\"$type parameter must be Number\");\n              }\n              continue;\n            }\n\n            if ('$not' === $cond) {\n              cast(schema, nested);\n            } else {\n              val[$cond] = schematype.castForQuery($cond, nested);\n            }\n          }\n        }\n      } else {\n        obj[path] = schematype.castForQuery(val);\n      }\n    }\n  }\n\n  return obj;\n}\n"]}
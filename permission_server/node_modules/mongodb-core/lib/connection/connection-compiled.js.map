{"version":3,"sources":["connection.js"],"names":[],"mappings":"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","file":"connection-compiled.js","sourcesContent":["\"use strict\";\n\nvar inherits = require('util').inherits\n  , EventEmitter = require('events').EventEmitter\n  , net = require('net')\n  , tls = require('tls')\n  , f = require('util').format\n  , getSingleProperty = require('./utils').getSingleProperty\n  , debugOptions = require('./utils').debugOptions\n  , Response = require('./commands').Response\n  , MongoError = require('../error')\n  , Logger = require('./logger');\n\nvar _id = 0;\nvar debugFields = ['host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay'\n  , 'connectionTimeout', 'socketTimeout', 'singleBufferSerializtion', 'ssl', 'ca', 'cert'\n  , 'rejectUnauthorized', 'promoteLongs'];\n\n/**\n * Creates a new Connection instance\n * @class\n * @param {string} options.host The server host\n * @param {number} options.port The server port\n * @param {number} [options.size=5] Server connection pool size\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.keepAliveInitialDelay=0] Initial delay before TCP keep alive enabled\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\n * @param {number} [options.connectionTimeout=0] TCP Connection timeout setting\n * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\n * @param {boolean} [options.singleBufferSerializtion=true] Serialize into single buffer, trade of peak memory for serialization speed\n * @param {boolean} [options.ssl=false] Use SSL for connection\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\n * @param {Buffer} [options.key] SSL Key file binary buffer\n * @param {string} [options.passphrase] SSL Certificate pass phrase\n * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\n * @fires Connection#connect\n * @fires Connection#close\n * @fires Connection#error\n * @fires Connection#timeout\n * @fires Connection#parseError\n * @return {Connection} A cursor instance\n */\nvar Connection = function(options) {\n  // Add event listener\n  EventEmitter.call(this);\n  // Set empty if no options passed\n  this.options = options || {};\n  // Identification information\n  this.id = _id++;\n  // Logger instance\n  this.logger = Logger('Connection', options);\n  // No bson parser passed in\n  if(!options.bson) throw new Error(\"must pass in valid bson parser\");\n  // Get bson parser\n  this.bson = options.bson;\n  // Grouping tag used for debugging purposes\n  this.tag = options.tag;\n  // Message handler\n  this.messageHandler = options.messageHandler;\n\n  // Max BSON message size\n  this.maxBsonMessageSize = options.maxBsonMessageSize || (1024 * 1024 * 16 * 4);\n  // Debug information\n  if(this.logger.isDebug()) this.logger.debug(f('creating connection %s with options [%s]', this.id, JSON.stringify(debugOptions(debugFields, options))));\n\n  // Default options\n  this.port = options.port || 27017;\n  this.host = options.host || 'localhost';\n  this.keepAlive = typeof options.keepAlive == 'boolean' ? options.keepAlive : true;\n  this.keepAliveInitialDelay = options.keepAliveInitialDelay || 0;\n  this.noDelay = typeof options.noDelay == 'boolean' ? options.noDelay : true;\n  this.connectionTimeout = options.connectionTimeout || 0;\n  this.socketTimeout = options.socketTimeout || 0;\n\n  // Check if we have a domain socket\n  this.domainSocket = this.host.indexOf('\\/') != -1;\n\n  // Serialize commands using function\n  this.singleBufferSerializtion = typeof options.singleBufferSerializtion == 'boolean' ? options.singleBufferSerializtion : true;\n  this.serializationFunction = this.singleBufferSerializtion ? 'toBinUnified' : 'toBin';\n\n  // SSL options\n  this.ca = options.ca || null;\n  this.cert = options.cert || null;\n  this.key = options.key || null;\n  this.passphrase = options.passphrase || null;\n  this.ssl = typeof options.ssl == 'boolean' ? options.ssl : false;\n  this.rejectUnauthorized = typeof options.rejectUnauthorized == 'boolean' ? options.rejectUnauthorized : true\n\n  // If ssl not enabled\n  if(!this.ssl) this.rejectUnauthorized = false;\n\n  // Response options\n  this.responseOptions = {\n    promoteLongs: typeof options.promoteLongs == 'boolean' ?  options.promoteLongs : true\n  }\n\n  // Flushing\n  this.flushing = false;\n  this.queue = [];\n\n  // Internal state\n  this.connection = null;\n  this.writeStream = null;\n}\n\ninherits(Connection, EventEmitter);\n\n//\n// Connection handlers\nvar errorHandler = function(self) {\n  return function(err) {\n    // Debug information\n    if(self.logger.isDebug()) self.logger.debug(f('connection %s for [%s:%s] errored out with [%s]', self.id, self.host, self.port, JSON.stringify(err)));\n    // Emit the error\n    if(self.listeners('error').length > 0) self.emit(\"error\", MongoError.create(err), self);\n  }\n}\n\nvar timeoutHandler = function(self) {\n  return function() {\n    // Debug information\n    if(self.logger.isDebug()) self.logger.debug(f('connection %s for [%s:%s] timed out', self.id, self.host, self.port));\n    // Emit timeout error\n    self.emit(\"timeout\"\n      , MongoError.create(f(\"connection %s to %s:%s timed out\", self.id, self.host, self.port))\n      , self);\n  }\n}\n\nvar closeHandler = function(self) {\n  return function(hadError) {\n    // Debug information\n    if(self.logger.isDebug()) self.logger.debug(f('connection %s with for [%s:%s] closed', self.id, self.host, self.port));\n    // Emit close event\n    if(!hadError) {\n      self.emit(\"close\"\n        , MongoError.create(f(\"connection %s to %s:%s closed\", self.id, self.host, self.port))\n        , self);\n    }\n  }\n}\n\nvar dataHandler = function(self) {\n  return function(data) {\n    // Parse until we are done with the data\n    while(data.length > 0) {\n      // If we still have bytes to read on the current message\n      if(self.bytesRead > 0 && self.sizeOfMessage > 0) {\n        // Calculate the amount of remaining bytes\n        var remainingBytesToRead = self.sizeOfMessage - self.bytesRead;\n        // Check if the current chunk contains the rest of the message\n        if(remainingBytesToRead > data.length) {\n          // Copy the new data into the exiting buffer (should have been allocated when we know the message size)\n          data.copy(self.buffer, self.bytesRead);\n          // Adjust the number of bytes read so it point to the correct index in the buffer\n          self.bytesRead = self.bytesRead + data.length;\n\n          // Reset state of buffer\n          data = new Buffer(0);\n        } else {\n          // Copy the missing part of the data into our current buffer\n          data.copy(self.buffer, self.bytesRead, 0, remainingBytesToRead);\n          // Slice the overflow into a new buffer that we will then re-parse\n          data = data.slice(remainingBytesToRead);\n\n          // Emit current complete message\n          try {\n            var emitBuffer = self.buffer;\n            // Reset state of buffer\n            self.buffer = null;\n            self.sizeOfMessage = 0;\n            self.bytesRead = 0;\n            self.stubBuffer = null;\n            // Emit the buffer\n            self.messageHandler(new Response(self.bson, emitBuffer, self.responseOptions), self);\n          } catch(err) {\n            var errorObject = {err:\"socketHandler\", trace:err, bin:self.buffer, parseState:{\n              sizeOfMessage:self.sizeOfMessage,\n              bytesRead:self.bytesRead,\n              stubBuffer:self.stubBuffer}};\n            // We got a parse Error fire it off then keep going\n            self.emit(\"parseError\", errorObject, self);\n          }\n        }\n      } else {\n        // Stub buffer is kept in case we don't get enough bytes to determine the\n        // size of the message (< 4 bytes)\n        if(self.stubBuffer != null && self.stubBuffer.length > 0) {\n          // If we have enough bytes to determine the message size let's do it\n          if(self.stubBuffer.length + data.length > 4) {\n            // Prepad the data\n            var newData = new Buffer(self.stubBuffer.length + data.length);\n            self.stubBuffer.copy(newData, 0);\n            data.copy(newData, self.stubBuffer.length);\n            // Reassign for parsing\n            data = newData;\n\n            // Reset state of buffer\n            self.buffer = null;\n            self.sizeOfMessage = 0;\n            self.bytesRead = 0;\n            self.stubBuffer = null;\n\n          } else {\n\n            // Add the the bytes to the stub buffer\n            var newStubBuffer = new Buffer(self.stubBuffer.length + data.length);\n            // Copy existing stub buffer\n            self.stubBuffer.copy(newStubBuffer, 0);\n            // Copy missing part of the data\n            data.copy(newStubBuffer, self.stubBuffer.length);\n            // Exit parsing loop\n            data = new Buffer(0);\n          }\n        } else {\n          if(data.length > 4) {\n            // Retrieve the message size\n            // var sizeOfMessage = data.readUInt32LE(0);\n            var sizeOfMessage = data[0] | data[1] << 8 | data[2] << 16 | data[3] << 24;\n            // If we have a negative sizeOfMessage emit error and return\n            if(sizeOfMessage < 0 || sizeOfMessage > self.maxBsonMessageSize) {\n              var errorObject = {err:\"socketHandler\", trace:'', bin:self.buffer, parseState:{\n                sizeOfMessage: sizeOfMessage,\n                bytesRead: self.bytesRead,\n                stubBuffer: self.stubBuffer}};\n              // We got a parse Error fire it off then keep going\n              self.emit(\"parseError\", errorObject, self);\n              return;\n            }\n\n            // Ensure that the size of message is larger than 0 and less than the max allowed\n            if(sizeOfMessage > 4 && sizeOfMessage < self.maxBsonMessageSize && sizeOfMessage > data.length) {\n              self.buffer = new Buffer(sizeOfMessage);\n              // Copy all the data into the buffer\n              data.copy(self.buffer, 0);\n              // Update bytes read\n              self.bytesRead = data.length;\n              // Update sizeOfMessage\n              self.sizeOfMessage = sizeOfMessage;\n              // Ensure stub buffer is null\n              self.stubBuffer = null;\n              // Exit parsing loop\n              data = new Buffer(0);\n\n            } else if(sizeOfMessage > 4 && sizeOfMessage < self.maxBsonMessageSize && sizeOfMessage == data.length) {\n              try {\n                var emitBuffer = data;\n                // Reset state of buffer\n                self.buffer = null;\n                self.sizeOfMessage = 0;\n                self.bytesRead = 0;\n                self.stubBuffer = null;\n                // Exit parsing loop\n                data = new Buffer(0);\n                // Emit the message\n                self.messageHandler(new Response(self.bson, emitBuffer, self.responseOptions), self);\n              } catch (err) {\n                var errorObject = {err:\"socketHandler\", trace:err, bin:self.buffer, parseState:{\n                  sizeOfMessage:self.sizeOfMessage,\n                  bytesRead:self.bytesRead,\n                  stubBuffer:self.stubBuffer}};\n                // We got a parse Error fire it off then keep going\n                self.emit(\"parseError\", errorObject, self);\n              }\n            } else if(sizeOfMessage <= 4 || sizeOfMessage > self.maxBsonMessageSize) {\n              var errorObject = {err:\"socketHandler\", trace:null, bin:data, parseState:{\n                sizeOfMessage:sizeOfMessage,\n                bytesRead:0,\n                buffer:null,\n                stubBuffer:null}};\n              // We got a parse Error fire it off then keep going\n              self.emit(\"parseError\", errorObject, self);\n\n              // Clear out the state of the parser\n              self.buffer = null;\n              self.sizeOfMessage = 0;\n              self.bytesRead = 0;\n              self.stubBuffer = null;\n              // Exit parsing loop\n              data = new Buffer(0);\n            } else {\n              var emitBuffer = data.slice(0, sizeOfMessage);\n              // Reset state of buffer\n              self.buffer = null;\n              self.sizeOfMessage = 0;\n              self.bytesRead = 0;\n              self.stubBuffer = null;\n              // Copy rest of message\n              data = data.slice(sizeOfMessage);\n              // Emit the message\n              self.messageHandler(new Response(self.bson, emitBuffer, self.responseOptions), self);\n            }\n          } else {\n            // Create a buffer that contains the space for the non-complete message\n            self.stubBuffer = new Buffer(data.length)\n            // Copy the data to the stub buffer\n            data.copy(self.stubBuffer, 0);\n            // Exit parsing loop\n            data = new Buffer(0);\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Connect\n * @method\n */\nConnection.prototype.connect = function(_options) {\n  var self = this;\n  _options = _options || {};\n  // Check if we are overriding the promoteLongs\n  if(typeof _options.promoteLongs == 'boolean') {\n    self.responseOptions.promoteLongs = _options.promoteLongs;\n  }\n\n  // Create new connection instance\n  self.connection = self.domainSocket\n    ? net.createConnection(self.host)\n    : net.createConnection(self.port, self.host);\n\n  // Set the options for the connection\n  self.connection.setKeepAlive(self.keepAlive, self.keepAliveInitialDelay);\n  self.connection.setTimeout(self.connectionTimeout);\n  self.connection.setNoDelay(self.noDelay);\n\n  // If we have ssl enabled\n  if(self.ssl) {\n    var sslOptions = {\n        socket: self.connection\n      , rejectUnauthorized: self.rejectUnauthorized\n    }\n\n    if(self.ca) sslOptions.ca = self.ca;\n    if(self.cert) sslOptions.cert = self.cert;\n    if(self.key) sslOptions.key = self.key;\n    if(self.passphrase) sslOptions.passphrase = self.passphrase;\n\n    // Attempt SSL connection\n    self.connection = tls.connect(self.port, self.host, sslOptions, function() {\n      // Error on auth or skip\n      if(self.connection.authorizationError && self.rejectUnauthorized) {\n        return self.emit(\"error\", self.connection.authorizationError, self, {ssl:true});\n      }\n\n      // Set socket timeout instead of connection timeout\n      self.connection.setTimeout(self.socketTimeout);\n      // We are done emit connect\n      self.emit('connect', self);\n    });\n  } else {\n    self.connection.on('connect', function() {\n      // Set socket timeout instead of connection timeout\n      self.connection.setTimeout(self.socketTimeout);\n      // Emit connect event\n      self.emit('connect', self);\n    });\n  }\n\n  // Add handlers for events\n  self.connection.once('error', errorHandler(self));\n  self.connection.once('timeout', timeoutHandler(self));\n  self.connection.once('close', closeHandler(self));\n  self.connection.on('data', dataHandler(self));\n}\n\n/**\n * Destroy connection\n * @method\n */\nConnection.prototype.destroy = function() {\n  if(this.connection) this.connection.destroy();\n}\n\n/**\n * Write to connection\n * @method\n * @param {Command} command Command to write out need to implement toBin and toBinUnified\n */\nConnection.prototype.write = function(buffer) {\n  // Debug log\n  if(this.logger.isDebug()) this.logger.debug(f('writing buffer [%s] to %s:%s', buffer.toString('hex'), this.host, this.port));\n  // Write out the command\n  this.connection.write(buffer, 'binary');\n}\n\n/**\n * Return id of connection as a string\n * @method\n * @return {string}\n */\nConnection.prototype.toString = function() {\n  return \"\" + this.id;\n}\n\n/**\n * Return json object of connection\n * @method\n * @return {object}\n */\nConnection.prototype.toJSON = function() {\n  return {id: this.id, host: this.host, port: this.port};\n}\n\n/**\n * Is the connection connected\n * @method\n * @return {boolean}\n */\nConnection.prototype.isConnected = function() {\n  return !this.connection.destroyed && this.connection.writable;\n}\n\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Connection#connect\n * @type {Connection}\n */\n\n/**\n * The server connection closed, all pool connections closed\n *\n * @event Connection#close\n * @type {Connection}\n */\n\n/**\n * The server connection caused an error, all pool connections closed\n *\n * @event Connection#error\n * @type {Connection}\n */\n\n/**\n * The server connection timed out, all pool connections closed\n *\n * @event Connection#timeout\n * @type {Connection}\n */\n\n/**\n * The driver experienced an invalid message, all pool connections closed\n *\n * @event Connection#parseError\n * @type {Connection}\n */\n\nmodule.exports = Connection;\n"]}